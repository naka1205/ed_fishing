#include "SDL2/SDL_blendmode.h"
#include "SG_Engine/extensions/SDL_gfx_mod.h"
#include <stdlib.h>
int _gfxPrimitivesCompareInt(const void *a, const void *b)
{
	return (*(const int *)a) - (*(const int *)b);
}
int _HLineTextured(SDL_Renderer *renderer, Sint16 x1, Sint16 x2, Sint16 y, SDL_Texture *texture, int texture_w, int texture_h, int texture_dx, int texture_dy)
{
	Sint16 w;
	Sint16 xtmp;
	int result = 0;
	int texture_x_walker;
	int texture_y_start;
	SDL_Rect source_rect, dst_rect;
	int pixels_written, write_width;

	if (x1 > x2)
	{
		xtmp = x1;
		x1 = x2;
		x2 = xtmp;
	}

	w = x2 - x1 + 1;

	texture_x_walker = (x1 - texture_dx) % texture_w;
	if (texture_x_walker < 0)
	{
		texture_x_walker = texture_w + texture_x_walker;
	}

	texture_y_start = (y + texture_dy) % texture_h;
	if (texture_y_start < 0)
	{
		texture_y_start = texture_h + texture_y_start;
	}

	// setup the source rectangle; we are only drawing one horizontal line
	source_rect.y = texture_y_start;
	source_rect.x = texture_x_walker;
	source_rect.h = 1;

	// we will draw to the current y
	dst_rect.y = y;
	dst_rect.h = 1;

	// if there are enough pixels left in the current row of the texture
	// draw it all at once
	if (w <= texture_w - texture_x_walker)
	{
		source_rect.w = w;
		source_rect.x = texture_x_walker;
		dst_rect.x = x1;
		dst_rect.w = source_rect.w;
		result = (SDL_RenderCopy(renderer, texture, &source_rect, &dst_rect) == 0);
	}
	else
	{
		// we need to draw multiple times
		// draw the first segment
		pixels_written = texture_w - texture_x_walker;
		source_rect.w = pixels_written;
		source_rect.x = texture_x_walker;
		dst_rect.x = x1;
		dst_rect.w = source_rect.w;
		result |= (SDL_RenderCopy(renderer, texture, &source_rect, &dst_rect) == 0);
		write_width = texture_w;

		// now draw the rest
		// set the source x to 0
		source_rect.x = 0;
		while (pixels_written < w)
		{
			if (write_width >= w - pixels_written)
			{
				write_width = w - pixels_written;
			}
			source_rect.w = write_width;
			dst_rect.x = x1 + pixels_written;
			dst_rect.w = source_rect.w;
			result |= (SDL_RenderCopy(renderer, texture, &source_rect, &dst_rect) == 0);
			pixels_written += write_width;
		}
	}

	return result;
}

// static int *gfxPrimitivesPolyIntsGlobalMod = NULL;
// static int gfxPrimitivesPolyAllocatedGlobalMod = 0;

int texturedPolygonMod(SDL_Renderer *renderer, const Sint16 *vx, const Sint16 *vy, int n, SDL_Texture *texture, int texture_dx, int texture_dy)
{
	int result;
	int i;
	int y, xa, xb;
	int minx, maxx, miny, maxy;
	int x1, y1;
	int x2, y2;
	int ind1, ind2;
	int ints;
	int *gfxPrimitivesPolyInts = NULL;
	int gfxPrimitivesPolyAllocated = 0;
	// SDL_Texture *textureAsTexture = NULL;

	int textureW = 0, textureH = 0;

	if (n < 3)
	{
		return -1;
	}

	// Use global cache
	// gfxPrimitivesPolyInts = gfxPrimitivesPolyIntsGlobalMod;
	// gfxPrimitivesPolyAllocated = gfxPrimitivesPolyAllocatedGlobalMod;

	if (!gfxPrimitivesPolyAllocated)
	{
		gfxPrimitivesPolyInts = (int *)malloc(sizeof(int) * n);
		gfxPrimitivesPolyAllocated = n;
	}
	else
	{
		if (gfxPrimitivesPolyAllocated < n)
		{
			gfxPrimitivesPolyInts = (int *)realloc(gfxPrimitivesPolyInts, sizeof(int) * n);
			gfxPrimitivesPolyAllocated = n;
		}
	}

	if (gfxPrimitivesPolyInts == NULL)
	{
		gfxPrimitivesPolyAllocated = 0;
	}

	// Update cache variables
	// gfxPrimitivesPolyIntsGlobalMod = gfxPrimitivesPolyInts;
	// gfxPrimitivesPolyAllocatedGlobalMod = gfxPrimitivesPolyAllocated;

	if (gfxPrimitivesPolyInts == NULL)
	{
		return (-1);
	}

	miny = vy[0];
	maxy = vy[0];
	minx = vx[0];
	maxx = vx[0];
	for (i = 1; (i < n); i++)
	{
		if (vy[i] < miny)
		{
			miny = vy[i];
		}
		else if (vy[i] > maxy)
		{
			maxy = vy[i];
		}
		if (vx[i] < minx)
		{
			minx = vx[i];
		}
		else if (vx[i] > maxx)
		{
			maxx = vx[i];
		}
	}

	// Create texture for drawing
	// textureAsTexture = SDL_CreateTextureFromSurface(renderer, texture);
	if (texture == NULL)
	{
		return -1;
	}

	SDL_QueryTexture(texture, NULL, NULL, &textureW, &textureH);

	SDL_SetTextureBlendMode(texture, SDL_BLENDMODE_BLEND);

	result = 0;
	for (y = miny; (y <= maxy); y++)
	{
		ints = 0;
		for (i = 0; (i < n); i++)
		{
			if (!i)
			{
				ind1 = n - 1;
				ind2 = 0;
			}
			else
			{
				ind1 = i - 1;
				ind2 = i;
			}
			y1 = vy[ind1];
			y2 = vy[ind2];
			if (y1 < y2)
			{
				x1 = vx[ind1];
				x2 = vx[ind2];
			}
			else if (y1 > y2)
			{
				y2 = vy[ind1];
				y1 = vy[ind2];
				x2 = vx[ind1];
				x1 = vx[ind2];
			}
			else
			{
				continue;
			}
			if (((y >= y1) && (y < y2)) || ((y == maxy) && (y > y1) && (y <= y2)))
			{
				gfxPrimitivesPolyInts[ints++] = ((65536 * (y - y1)) / (y2 - y1)) * (x2 - x1) + (65536 * x1);
			}
		}

		qsort(gfxPrimitivesPolyInts, ints, sizeof(int), _gfxPrimitivesCompareInt);

		for (i = 0; (i < ints); i += 2)
		{
			xa = gfxPrimitivesPolyInts[i] + 1;
			xa = (xa >> 16) + ((xa & 32768) >> 15);
			xb = gfxPrimitivesPolyInts[i + 1] - 1;
			xb = (xb >> 16) + ((xb & 32768) >> 15);
			result |= _HLineTextured(renderer, xa, xb, y, texture, textureW, textureH, texture_dx, texture_dy);
		}
	}

	// SDL_RenderPresent(renderer);
	// SDL_DestroyTexture(textureAsTexture);
	free(gfxPrimitivesPolyInts);

	return (result);
}
